#include "Include.h"
void Enemy::initPos() {
	// mPos = Vector2D(550, 850 / 2);		// 초기위치
	mVelo = Vector2D(2, 2);
	mSize = Vector2D(50, 50);
	
	m_Texid = NULL;
	
	mColor = Color4f(0.1, 0.1, 0.8, 0.5);
	MoveSpeed = 2.0f;
	gravity = 4;
	OnGround = false;
	OnCollide = false;
	loadTexture();
}

void Enemy::initTexture(const char *name)
{
	// mPos = Vector2D(550, 850 / 2);		// 초기위치
	mVelo = Vector2D(2, 2);
	mSize = Vector2D(50, 100);

	m_Tex.LoadImage(name);
	m_Texid = NULL;
	m_Texid = *m_Tex.GetTexture();

	mColor = Color4f(1, 1, 1, 1);
	MoveSpeed = 2.0f;
	gravity = 4;
	OnGround = false;
	OnCollide = false;
}
void Enemy::Transform()
{
	mTop = mPos.y - mSize.y / 2;
	mBottom = mPos.y + mSize.y / 2;
	mRight = mPos.x + mSize.x / 2;
	mLeft = mPos.x - mSize.x / 2;

	vLT = Vector2D(mLeft, mTop);
	vRT = Vector2D(mRight, mTop);
	vRB = Vector2D(mRight, mBottom);
	vLB = Vector2D(mLeft, mBottom);
}

void Enemy::Render()
{
	glPushMatrix();			// 현재 모델뷰 행렬을 스택에 저장하는 함수
	glBindTexture(GL_TEXTURE_2D, m_Texid);
	// 현재 활성화된 텍스처 유닛에 2D 텍스처를 바인딩하는 함수

	// 현재의 색상을 설정하는 함수
	glColor4f(mColor.r, mColor.g, mColor.b, mColor.a);

	glMatrixMode(GL_MODELVIEW);			// 현재의 행렬 모드를 설정하는 함수
	glLoadIdentity();					// 현재 행렬을 단위 행렬로 초기화

	glTranslatef(mPos.x, g_Extern.WINDOWSIZE_HEIGHT - mPos.y, 0);
	glScalef(-mSize.x, mSize.y, 1);

	DrawBox(1);

	glBindTexture(GL_TEXTURE_2D, 0);		// 텍스처 언바인딩
	glPopMatrix();			// 스택에 저장된 이전의 모델뷰 행렬을 복원하는 함수
}


bool Enemy::Collide(Sprite other)
{
	// 축 검사해서 겹치면 
	// bottom > other.top (일반 좌표)
	// 실시간이라 변수로 계산 X
	if ((mRight >= other.mLeft)
		&& (mLeft <= other.mRight)
		&& (mBottom >= other.mTop)
		&& (mTop <= other.mBottom))
	{
		OnCollide = true;
		return true;
	}
	OnCollide = false;
	return false; // 충돌 하지 않음.
}

void Enemy::InputController() 
{
	mPos.y += gravity;
	mPos.x -= mVelo.x;
}
